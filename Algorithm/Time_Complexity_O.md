### 時間複雜度 ### 

1. 複雜度最小為 O(1)
1. 複雜度最大為 O(2^n)


*** O(1) ***

販賣機上有 [芬達,舒跑,雪碧,可樂,綠茶] ,我選樂可樂

已經知道陣列上第四個是 可樂 , 所以 str[3]="可樂"

重點 : 

(1) 一次就找到,因為選第四個就是可樂
(2) 已知索引

*** O(n) ***

販賣機上有各 [芬達,舒跑,雪碧,可樂,綠茶] 不同種類的飲料
他被裝成福袋放進販賣機變這樣 => [福袋,福袋,福袋,福袋,福袋] 
然後我想喝可樂

foreach(int index in 販賣機)
{
    if(販賣機[index]===可樂)
    {
        幹我找到了!
    }
    else
    {
        幹這不是可樂!
    }
}

重點 : 

(1) 運氣好 1 次就找到,運氣不好要開 5 次
(2) 假設數量延伸到 n 個 , 夠衰的情況我要開 n 次 => O(n)
(2) 未知索引 , 簡易搜尋

*** O(log n) ***

大致概念(沒用中位數):

我要查字典 Junior 
=> 找 J 的類別
拿起我的字典
=> 此時範圍是 A ~ Z
打開字典翻開翻到 E, E 在 J 的左邊
=> 此時範圍是 E ~ Z
縮小範圍後繼續翻開到 R, R 在 J 的右邊
=> 此時範圍是 E ~ R
縮小範圍後繼續翻開到 K, K 在 J 的左邊
=> 此時範圍是 E ~ K

(依此類推)

正確一點的概念:

我要查字典 King
=> 找 K 的類別
然後這爛字典 
但只有 [I,J,K,L,M,N,O] 七個大類

拿起我的字典
=> 此時範圍是 I ~ O
打開字典 翻開一半 翻到 L, L 在 K 的右邊
=> 此時範圍是 I ~ M
縮小範圍後繼續 翻開一半 到 J, J 在 K 的左邊
=> 此時範圍是 E ~ R
縮小範圍後繼續翻開到 K, K 在 K 的......
=> 幹找到了啦

(依此類推)

重點 : 

(1) 根本就終極密碼
(2) 但是 每次抓的範圍 都要是 剩下的 中間值 
(3) 每做一個步驟排除 一半 不符合的
(4) 最多次數為 => 以 2 為底(二分法) 的 log7 =2.8073 (無條件進入) => 3 => 最衰的話要找 3 次
(4) 當有 N 個數 => logN


#### 參考頁面 ####

https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E8%AB%87%E4%BB%80%E9%BA%BC%E6%98%AF%E6%BC%94%E7%AE%97%E6%B3%95%E5%92%8C%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6-b1f6908e4b80

https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E5%BE%9E%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6%E8%AA%8D%E8%AD%98%E5%B8%B8%E8%A6%8B%E6%BC%94%E7%AE%97%E6%B3%95-%E4%B8%80-b46fece65ba5